{
  parserClass='com.github.themartdev.intellijgleam.lang.parser.GleamParser'

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  elementTypeHolderClass='com.github.themartdev.intellijgleam.lang.psi.GleamTypes'
  elementTypeClass='com.github.themartdev.intellijgleam.lang.psi.GleamElementType'
  tokenTypeClass='com.github.themartdev.intellijgleam.lang.psi.GleamTokenType'

  psiClassPrefix='Gleam'
  psiImplClassSuffix='Impl'
  psiPackage="com.github.themartdev.intellijgleam.lang.psi"
  psiImplPackage="com.github.themartdev.intellijgleam.lang.psi.impl"
  psiImplUtilClass="com.github.themartdev.intellijgleam.lang.psi.impl.GleamPsiImplUtil"

  tokens=[
    EOL             = '\\n, \\r\\n'
    // Language keywords https://github.com/gleam-lang/gleam/blob/main/compiler-core/src/parse/lexer.rs#L24
    AS              = 'as'
    ASSERT          = 'assert'
    CASE            = 'case'
    CONST           = 'const'
    FN              = 'fn'
    IF              = 'if'
    IMPORT          = 'import'
    LET             = 'let'
    OPAQUE          = 'opaque'
    PANIC           = 'panic'
    PUB             = 'pub'
    TEST            = 'test'
    TODO            = 'todo'
    TYPE            = 'type'
    USE             = 'use'

    // Grouping symbols
    LBRACE          = '{'
    RBRACE          = '}'
    LPAREN          = '('
    RPAREN          = ')'
    LBRACK          = '['
    RBRACK          = ']'

    // Operators and punctuation
    DOT             = '.'
    COMMA           = ','
    COLON           = ':'
    HASH            = '#'
    BANG            = '!'
    EQUAL           = '='
    EQUAL_EQUAL     = '=='
    NOT_EQUAL       = '!='
    VBAR            = '|'
    VBAR_VBAR       = '||'
    AMPER_AMPER     = '&&'
    LT_LT           = '<<'
    GT_GT           = '>>'
    PIPE            = '|>'
    R_ARROW         = '->'
    L_ARROW         = '<-'
    DOT_DOT         = '..'
    PLUS            = '+'
    MINUS           = '-'
    STAR            = '*'
    SLASH           = '/'
    LESS            = '<'
    GREATER         = '>'
    LESS_EQUAL      = '<='
    GREATER_EQUAL   = '>='
    PERCENT         = '%'
    PLUS_DOT        = '+.'
    MINUS_DOT       = '-.'
    STAR_DOT        = '*.'
    SLASH_DOT       = '/.'
    LESS_DOT        = '<.'
    GREATER_DOT     = '>.'
    LESS_EQUAL_DOT  = '<=.'
    GREATER_EQUAL_DOT = '>=.'
    LT_GT           = '<>'

    //// Annotation
    DECORATOR_MARK = '@'
    DECORATOR_NAME = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Literals
    BOOLEAN_LITERAL = "regexp:True|False"

    // Identifiers
    DISCARD_NAME    = "regexp:_[_0-9a-z]*"
    UP_IDENTIFIER   = "regexp:[A-Z][a-zA-Z0-9_]*"
    IDENTIFIER      = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Comments
    MODULE_COMMENT  = "regexp:////[^\n]*"
    FUNCTION_COMMENT="regexp:///[^\n]*"
    LINE_COMMENT    = "regexp://[^\n]*"

    // String stuff
    OPEN_QUOTE      = '"'
    CLOSE_QUOTE     = '"'
    REGULAR_STRING_PART = "regexp:[^\\\"]*"
    ESCAPE          = "regexp:\\"
    ESCAPE_CHAR     = "regexp:[^u\n\r]"
    UNICODE_ESCAPE_CHAR = "u"
    UNICODE_CODEPOINT = "regexp:[0-9a-fA-F]{1,6}"
    INVALID_UNICODE_ESCAPE_SEQUENCE="regexp:[^0-9a-fA-F]"

    //// Number stuff
    VALID_DECIMAL_DIGIT   = "regexp:[0-9]+"
    INVALID_DECIMAL_DIGIT = "regexp:[a-zA-Z]+"
    NUMBER_SEPARATOR = "_"
    EXPONENT_MARK = "e (exponent)"
    DECIMAL_MARK = ". (decimal separator)"
    EXPONENT_SIGN = "regexp:[+-]"

    BASE_NUMBER_PREFIX = "0"

    BINARY_NUMBER_BASE = "regexp:[bB]"
    VALID_BINARY_DIGIT = "regexp:[01]"
    INVALID_BINARY_DIGIT = "regexp:[2-9a-zA-Z]"

    HEX_NUMBER_BASE = "regexp:[xX]"
    VALID_HEX_DIGIT = "regexp:[0-9a-fA-F]"
    INVALID_HEX_DIGIT = "regexp:[g-zG-Z]"

    OCTAL_NUMBER_BASE = "regexp:[oO]"
    VALID_OCTAL_DIGIT = "regexp:[0-7]"
    INVALID_OCTAL_DIGIT = "regexp:[8-9a-zA-Z]"

    UNKNOWN_NUMBER_BASE = "regexp:[a-zA-Z]"
    INVALID_UNKNOWN_BASE_DIGIT = "regexp:[a-zA-Z1-9]"
  ]

  extends(".*Expr")=expression
  extends(".*ExprConst")=expressionConst
  extends(".*Decorator")=decorator
}



root ::= topLevelDeclaration*

private topLevelDeclaration ::= importDeclaration
                            | constantDeclaration
                            | typeDeclaration
                            | functionDeclaration
                            | externalFunctionNoFallbackDeclaration
                            {
                              recoverWhile=declarationRecover
                            }
private declarationRecover ::= !topLevelKeyword
private topLevelKeyword ::= IMPORT | CONST | TYPE | FN | PUB | OPAQUE | DECORATOR_MARK


constantDeclaration ::= [visibilityModifier] CONST IDENTIFIER [constantTypeAnnotation] EQUAL expressionConst {pin=2}


// ===== External =====
externalFunctionSignature ::= [visibilityModifier] FN functionNameDefinition functionParameters [R_ARROW typeBase]
externalFunctionNoFallbackDeclaration ::=  externalDecorator (externalDecorator)* externalFunctionSignature {pin=1}

// ===== Imports =====
unqualifiedImport ::= identifier (AS aliasIdentifier)? {
  methods=[getNameOrAlias]
}
typeUnqualifiedImport ::= TYPE upIdentifier (AS aliasUpIdentifier)? {
  pin=1
  methods=[getNameOrAlias]
}
private unqualifiedImportBase ::= unqualifiedImport | typeUnqualifiedImport
unqualifiedImports ::= LBRACE [unqualifiedImportBase (COMMA unqualifiedImportBase)* [COMMA]] RBRACE
modulePath ::= IDENTIFIER (SLASH IDENTIFIER)* {
  pin=1
  methods=[getModuleName]
}

importDeclaration ::= IMPORT modulePath [DOT unqualifiedImports] [AS IDENTIFIER] {
  pin=1
  methods=[getNameOrAlias]
}

// ===== Decorators =====
externalTarget ::= "javascript" | "erlang"
externalDecoratorName ::= "external"
externalDecorator ::= DECORATOR_MARK externalDecoratorName LPAREN externalTarget COMMA stringLiteral COMMA stringLiteral RPAREN {pin=2}

deprecatedDecoratorName ::= "deprecated"
deprecatedDecorator ::= DECORATOR_MARK deprecatedDecoratorName LPAREN stringLiteral RPAREN {pin=2}

unknownDecoratorName ::= DECORATOR_NAME
private unknownDecoratorArgument ::= literalExpr | IDENTIFIER
unknownDecorator ::= DECORATOR_MARK unknownDecoratorName LPAREN [unknownDecoratorArgument (COMMA unknownDecoratorArgument)*] RPAREN

decorator ::= externalDecorator | deprecatedDecorator | unknownDecorator

// ===== Rest =====
constantFunctionParameterTypes ::= LPAREN [constantTypeSpecial (COMMA constantTypeSpecial)* [COMMA]] RPAREN
constantTypeFunction ::= FN [constantFunctionParameterTypes] R_ARROW constantTypeSpecial


constantTypeArgument ::= constantTypeSpecial
constantTypeArguments ::= LPAREN [constantTypeArgument (COMMA constantTypeArgument)* [COMMA]] RPAREN


constantType ::= typeName [constantTypeArguments]
constantTypeTuple ::= HASH LPAREN [constantTypeSpecial (COMMA constantTypeSpecial)* [COMMA]] RPAREN
constantTypeSpecial ::= typeName
                      | constantTypeTuple
                      | constantTypeFunction
                      | constantType
constantTypeAnnotation ::= COLON constantType


// ===== Constant expressions =====
expressionConst ::= literalExprConst
            | tupleExprConst
            | bitArrayExprConst
            | listExprConst
            | recordExprConst
            | fieldAccessExprConst
            // Can refer to another constant
            | identifierExprConst
literalExprConst ::= literal
tupleExprConst ::= HASH LPAREN [expressionConst (COMMA expressionConst)* [COMMA]] RPAREN {pin=2}
constantBitArraySegment ::= expressionConst [COLON bitArraySegmentOptions]
bitArrayExprConst ::= LT_LT [constantBitArraySegment (COMMA constantBitArraySegment)* [COMMA]] GT_GT {pin=1}
listExprConst ::= LBRACK [expressionConst (COMMA expressionConst)* [COMMA]] RBRACK {pin=1}
constantRecordArgument ::= [label COLON] expressionConst
constantRecordArguments ::= LPAREN [constantRecordArgument (COMMA constantRecordArgument)* [COMMA]] RPAREN
recordExprConst ::= typeName [constantRecordArguments]
fieldAccessExprConst ::= IDENTIFIER DOT label
identifierExprConst ::= identifier
// ============


functionParameterTypes ::= LPAREN [typeBase (COMMA typeBase)* [COMMA]] RPAREN
tupleType ::= HASH LPAREN [typeBase (COMMA typeBase)* [COMMA]] RPAREN {pin=2}
functionType ::= FN [functionParameterTypes] R_ARROW typeBase {pin=1}

typeBase ::=  tupleType | functionType | typeReference | genericType
typeAnnotation ::= COLON typeBase
genericType ::= identifier
typeArgument ::= typeBase
typeArguments ::= LPAREN [typeArgument (COMMA typeArgument)* [COMMA]] RPAREN
typeReference ::= typeName [typeArguments]

functionParameterArgs ::= labeledDiscardParam | discardParam | labeledNameParam | nameParam
functionParameter ::= functionParameterArgs [typeAnnotation]
functionParameters ::= LPAREN [functionParameter (COMMA functionParameter)* [COMMA]] RPAREN
functionBody ::= LBRACE [expressionSeq] RBRACE {pin=1}
functionDeclaration ::= (decorator)* [visibilityModifier] FN functionNameDefinition functionParameters [R_ARROW typeBase] functionBody
functionNameDefinition::= IDENTIFIER

listPatternTail ::= DOT_DOT [IDENTIFIER | discardIdentifier]
listPattern ::= LBRACK [pattern (COMMA pattern)* [COMMA]] [listPatternTail] RBRACK

stringPattern ::= stringLiteral LT_GT [IDENTIFIER | discardIdentifier]

patternSpread ::= DOT_DOT [COMMA]
recordPatternArgument ::= [label COLON] pattern
recordPatternArguments ::= LPAREN [recordPatternArgument (COMMA recordPatternArgument)* [COMMA]] [patternSpread] RPAREN
recordPattern ::= (constructorIdentifier | remoteConstructorIdentifier) [recordPatternArguments]
pattern ::= (IDENTIFIER | discardIdentifier | stringPattern | recordPattern | literalExpr | tuplePattern | patternBitArray | listPattern ) [AS IDENTIFIER]

expressionSeq ::= (expression)+

shortHandLabeledArgument ::= identifier COLON
labeledArgument ::= identifier COLON expression
unlabeledArgument ::= expression

recordArgument ::= labeledArgument | shortHandLabeledArgument | unlabeledArgument
private recordArgumentList ::= [recordArgument (COMMA recordArgument)* [COMMA]]
recordUpdate ::= DOT_DOT variableReference {pin=1}
// Record update can only be at the start of record arguments
recordArguments ::=  LPAREN (recordUpdate COMMA recordArgumentList | recordUpdate | recordArgumentList) RPAREN
recordExpr ::= (constructorIdentifier | remoteConstructorIdentifier) [recordArguments]

//private bitArrayRecover ::= !(GT_GT | LT_LT)

listExpr ::= LBRACK [expression ((COMMA expression)*)? [COMMA] [DOT_DOT expression]] RBRACK

anonymousFunctionParameterArgs ::= discardParam | nameParam
anonymousFunctionParameter ::= anonymousFunctionParameterArgs [typeAnnotation]
anonymousFunctionParameters ::= LPAREN [anonymousFunctionParameter (COMMA anonymousFunctionParameter)* [COMMA]] RPAREN
anonymousFunctionExpr ::= FN anonymousFunctionParameters [R_ARROW typeReference] functionBody

blockExpr ::= LBRACE expressionSeq RBRACE

caseClauseTupleAccess ::= IDENTIFIER DOT wholeNumber
caseClauseGuardUnit ::= IDENTIFIER | caseClauseTupleAccess | LBRACE caseClauseGuardExpression RBRACE | expressionConst
caseClauseGuardBinaryOperator ::= VBAR_VBAR | AMPER_AMPER | EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
                                | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT | GREATER_EQUAL_DOT
caseClauseGuardExpression ::= caseClauseGuardUnit caseClauseGuardTail*
caseClauseGuardTail ::= caseClauseGuardBinaryOperator caseClauseGuardUnit

caseClauseGuard ::= IF caseClauseGuardExpression
caseClausePattern ::= pattern (COMMA pattern)* [COMMA]
caseClausePatterns ::= caseClausePattern (VBAR caseClausePattern)* [VBAR]
caseClause ::= caseClausePatterns [caseClauseGuard] R_ARROW expression
caseClauses ::= caseClause+
caseSubjects ::= expression (COMMA expression)*
caseExprBody ::= LBRACE caseClauses RBRACE
caseExpr ::= CASE caseSubjects caseExprBody

useArgs ::= IDENTIFIER | IDENTIFIER COMMA useArgs
useExpr ::= USE [useArgs] L_ARROW expression

assignment ::= pattern [typeAnnotation] EQUAL expression
simpleLetExpr ::= LET assignment {pin=1}
assertLetExpr ::= LET ASSERT assignment {pin=2}
letExpr ::= assertLetExpr | simpleLetExpr

panicExpr ::= PANIC (AS stringLiteral)?
todoExpr ::= TODO (AS stringLiteral)?

recordUpdateArgument ::= label COLON expression
recordUpdateArguments ::= recordUpdateArgument (COMMA recordUpdateArgument)* [COMMA]
recordUpdateExpr ::= (constructorIdentifier | remoteConstructorIdentifier) LPAREN DOT_DOT expression COMMA recordUpdateArguments RPAREN



callExpr ::= expression recordArguments

accessExpr ::= expression DOT (label | wholeNumber)

referenceExpr ::= IDENTIFIER

private literal ::= floatLiteral
              | stringLiteral
              | integerLiteral
              | BOOLEAN_LITERAL
literalExpr ::= literal

private simpleKeywordExpr ::= letExpr | panicExpr | todoExpr
expression ::= simpleKeywordExpr
             | useExpr
             | caseExpr
             | tupleExpr
             | literalExpr
             | bitArrayExpr
             | callExpr
             | accessExpr
             | recordExpr
             | anonymousFunctionExpr
             | listExpr
             | blockExpr
             | recordUpdateExpr
             | referenceExpr
             | binaryExpr
             | unaryExpr

//private expressionRecoverWhile ::= !expressionRecoverUntil
//private expressionRecoverUntil ::= RBRACE | RPAREN | RBRACK | EOL

binaryExpr ::= expression binaryOperator expression
binaryOperator ::= EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
                 | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT
                 | GREATER_EQUAL_DOT | LT_GT | PIPE | PLUS | PLUS_DOT
                 | MINUS | MINUS_DOT | STAR | STAR_DOT | SLASH | SLASH_DOT
                 | PERCENT | AMPER_AMPER | VBAR_VBAR

unaryExpr ::= unaryOperator expression
unaryOperator ::= BANG | MINUS

// ===== Tuple =====
tuplePattern ::= HASH LPAREN [pattern (COMMA pattern)* [COMMA]] RPAREN
tupleExpr ::= HASH LPAREN [expression (COMMA expression)* [COMMA]] RPAREN {pin=2}

// ===== BitArray =====
bitArrayOptionName ::= IDENTIFIER
bitArraySegmentOption ::= bitArrayOptionName [LPAREN wholeNumber RPAREN] | wholeNumber
bitArraySegmentOptions ::= bitArraySegmentOption (MINUS bitArraySegmentOption)*

bitArraySegment ::= expression [COLON bitArraySegmentOptions]

patternBitArraySegment ::= pattern [COLON bitArraySegmentOptions]

patternBitArray ::= LT_LT [patternBitArraySegment (COMMA patternBitArraySegment)* [COMMA]] GT_GT
bitArrayExpr ::= LT_LT [bitArraySegment (COMMA bitArraySegment)* [COMMA]] GT_GT {pin=1}

// ===== Types =====
dataConstructorArgument ::= [label COLON] typeBase
dataConstructorArguments ::= LPAREN [dataConstructorArgument (COMMA dataConstructorArgument)* [COMMA]] RPAREN
dataConstructor ::= constructorIdentifier [dataConstructorArguments]
dataConstructors ::= dataConstructor+

referenceTypeValue ::= EQUAL typeReference
customTypeValue ::= LBRACE dataConstructors RBRACE
omittedTypeValue ::=
typeValue ::= referenceTypeValue | customTypeValue | omittedTypeValue
typeDeclarationName ::= UP_IDENTIFIER
typeDeclaration ::= [visibilityModifier] [OPAQUE] TYPE typeDeclarationName typeValue {pin=3}

// ===== Literals =====
// Numbers
binaryIntegerLiteral ::= BASE_NUMBER_PREFIX BINARY_NUMBER_BASE VALID_BINARY_DIGIT (NUMBER_SEPARATOR VALID_BINARY_DIGIT)*
octalIntegerLiteral ::= BASE_NUMBER_PREFIX OCTAL_NUMBER_BASE VALID_OCTAL_DIGIT (NUMBER_SEPARATOR VALID_OCTAL_DIGIT)*
hexIntegerLiteral ::= BASE_NUMBER_PREFIX HEX_NUMBER_BASE VALID_HEX_DIGIT (NUMBER_SEPARATOR VALID_HEX_DIGIT)*

wholeNumber ::= VALID_DECIMAL_DIGIT (NUMBER_SEPARATOR VALID_DECIMAL_DIGIT)*
decimalIntegerLiteral ::= wholeNumber

floatLiteral ::= wholeNumber DECIMAL_MARK wholeNumber? (EXPONENT_MARK EXPONENT_SIGN? wholeNumber)?
integerLiteral ::= binaryIntegerLiteral | octalIntegerLiteral | hexIntegerLiteral | decimalIntegerLiteral


//// Strings
stringEscapeSegment ::= (ESCAPE ESCAPE_CHAR) | (ESCAPE UNICODE_ESCAPE_CHAR LBRACE UNICODE_CODEPOINT RBRACE)
stringLiteral ::= OPEN_QUOTE (REGULAR_STRING_PART | stringEscapeSegment)* CLOSE_QUOTE


// Aliases
private identifier ::= IDENTIFIER
private upIdentifier ::= UP_IDENTIFIER
private discardIdentifier ::= DISCARD_NAME
private typeName ::= qualifiedTypeName | unqualifiedTypeName
aliasIdentifier ::= identifier
aliasUpIdentifier ::= upIdentifier

unqualifiedTypeName ::= upIdentifier
qualifiedTypeName ::= identifier DOT upIdentifier

// Aliases
variableReference ::= IDENTIFIER
constructorIdentifier ::= UP_IDENTIFIER
label ::= IDENTIFIER
discardParam ::= discardIdentifier
nameParam ::= IDENTIFIER
labeledNameParam ::= label IDENTIFIER
labeledDiscardParam ::= label discardIdentifier
remoteConstructorIdentifier ::= IDENTIFIER DOT constructorIdentifier
visibilityModifier ::= PUB
