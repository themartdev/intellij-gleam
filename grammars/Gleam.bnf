{
  parserClass='com.github.themartdev.intellijgleam.lang.parser.GleamParser'

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  elementTypeHolderClass='com.github.themartdev.intellijgleam.lang.psi.GleamTypes'
  elementTypeClass='com.github.themartdev.intellijgleam.lang.psi.GleamElementType'
  tokenTypeClass='com.github.themartdev.intellijgleam.lang.psi.GleamTokenType'

  psiClassPrefix='Gleam'
  psiImplClassSuffix='Impl'
  psiPackage="com.github.themartdev.intellijgleam.lang.psi"
  psiImplPackage="com.github.themartdev.intellijgleam.lang.psi.impl"

  extends(".*Expr")=expression
  extends(".*Decorator")=decorator

  tokens=[
    EOL             = '\\n, \\r\\n'
    // Language keywords https://github.com/gleam-lang/gleam/blob/main/compiler-core/src/parse/lexer.rs#L24
    AS              = 'as'
    ASSERT          = 'assert'
    CASE            = 'case'
    CONST           = 'const'
    FN              = 'fn'
    IF              = 'if'
    IMPORT          = 'import'
    LET             = 'let'
    OPAQUE          = 'opaque'
    PANIC           = 'panic'
    PUB             = 'pub'
    TEST            = 'test'
    TODO            = 'todo'
    TYPE            = 'type'
    USE             = 'use'

    // Grouping symbols
    LBRACE          = '{'
    RBRACE          = '}'
    LPAREN          = '('
    RPAREN          = ')'
    LBRACK          = '['
    RBRACK          = ']'

    // Operators and punctuation
    DOT             = '.'
    COMMA           = ','
    COLON           = ':'
    HASH            = '#'
    BANG            = '!'
    EQUAL           = '='
    EQUAL_EQUAL     = '=='
    NOT_EQUAL       = '!='
    VBAR            = '|'
    VBAR_VBAR       = '||'
    AMPER_AMPER     = '&&'
    LT_LT           = '<<'
    GT_GT           = '>>'
    PIPE            = '|>'
    R_ARROW         = '->'
    L_ARROW         = '<-'
    DOT_DOT         = '..'
    PLUS            = '+'
    MINUS           = '-'
    STAR            = '*'
    SLASH           = '/'
    LESS            = '<'
    GREATER         = '>'
    LESS_EQUAL      = '<='
    GREATER_EQUAL   = '>='
    PERCENT         = '%'
    PLUS_DOT        = '+.'
    MINUS_DOT       = '-.'
    STAR_DOT        = '*.'
    SLASH_DOT       = '/.'
    LESS_DOT        = '<.'
    GREATER_DOT     = '>.'
    LESS_EQUAL_DOT  = '<=.'
    GREATER_EQUAL_DOT = '>=.'
    LT_GT           = '<>'

    //// Annotation
    DECORATOR_MARK = '@'
    DECORATOR_NAME = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Literals
    BOOLEAN_LITERAL = "regexp:True|False"

    // Identifiers
    DISCARD_NAME    = "regexp:_[_0-9a-z]*"
    UP_IDENTIFIER   = "regexp:[A-Z][a-zA-Z0-9_]*"
    IDENTIFIER      = "regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // Comments
    MODULE_COMMENT  = "regexp:////[^\n]*"
    FUNCTION_COMMENT="regexp:///[^\n]*"
    LINE_COMMENT    = "regexp://[^\n]*"

    // String stuff
    OPEN_QUOTE      = '"'
    CLOSE_QUOTE     = '"'
    REGULAR_STRING_PART = "regexp:[^\\\"]*"
    ESCAPE          = "regexp:\\"
    ESCAPE_CHAR     = "regexp:[^u\n\r]"
    UNICODE_ESCAPE_CHAR = "u"
    UNICODE_CODEPOINT = "regexp:[0-9a-fA-F]{1,6}"
    INVALID_UNICODE_ESCAPE_SEQUENCE="regexp:[^0-9a-fA-F]"

    //// Number stuff
    VALID_DECIMAL_DIGIT   = "regexp:[0-9]+"
    INVALID_DECIMAL_DIGIT = "regexp:[a-zA-Z]+"
    NUMBER_SEPARATOR = "_"
    EXPONENT_MARK = "e (exponent)"
    DECIMAL_MARK = ". (decimal separator)"
    EXPONENT_SIGN = "regexp:[+-]"

    BASE_NUMBER_PREFIX = "0"

    BINARY_NUMBER_BASE = "regexp:[bB]"
    VALID_BINARY_DIGIT = "regexp:[01]"
    INVALID_BINARY_DIGIT = "regexp:[2-9a-zA-Z]"

    HEX_NUMBER_BASE = "regexp:[xX]"
    VALID_HEX_DIGIT = "regexp:[0-9a-fA-F]"
    INVALID_HEX_DIGIT = "regexp:[g-zG-Z]"

    OCTAL_NUMBER_BASE = "regexp:[oO]"
    VALID_OCTAL_DIGIT = "regexp:[0-7]"
    INVALID_OCTAL_DIGIT = "regexp:[8-9a-zA-Z]"

    UNKNOWN_NUMBER_BASE = "regexp:[a-zA-Z]"
    INVALID_UNKNOWN_BASE_DIGIT = "regexp:[a-zA-Z1-9]"
  ]
}



root ::= topLevelStatement*

private topLevelStatement ::= importStatement
                            | constant
                            | typeDeclaration
                            | functionDeclaration
                            | externalFunctionNoFallback

// Decorators
externalTarget ::= "javascript" | "erlang"
externalDecoratorName ::= "external"
externalDecorator ::= DECORATOR_MARK externalDecoratorName LPAREN externalTarget COMMA stringLiteral COMMA stringLiteral RPAREN {pin=2}

deprecatedDecoratorName ::= "deprecated"
deprecatedDecorator ::= DECORATOR_MARK deprecatedDecoratorName LPAREN stringLiteral RPAREN {pin=2}

unknownDecoratorName ::= DECORATOR_NAME
private unknownDecoratorArgument ::= literalExpr | IDENTIFIER
unknownDecorator ::= DECORATOR_MARK unknownDecoratorName LPAREN [unknownDecoratorArgument (COMMA unknownDecoratorArgument)*] RPAREN {pin=1}

decorator ::= externalDecorator | deprecatedDecorator | unknownDecorator

// External
//functionDeclaration ::= (decorator)* [visibilityModifier] FN functionNameDefinition functionParameters [R_ARROW typeBase] functionBody
externalFunctionSignature ::= [visibilityModifier] FN functionNameDefinition functionParameters [R_ARROW typeBase]
externalFunctionNoFallback ::=  externalDecorator (externalDecorator)* externalFunctionSignature

// Imports
module ::= IDENTIFIER (SLASH IDENTIFIER)*
unqualifiedImport ::= IDENTIFIER (AS IDENTIFIER)? | [TYPE] UP_IDENTIFIER (AS UP_IDENTIFIER)?
unqualifiedImports ::= LBRACE [unqualifiedImport (COMMA unqualifiedImport)* [COMMA]] RBRACE
importStatement ::= IMPORT module [DOT unqualifiedImports] [AS IDENTIFIER]

// Types
constantFunctionParameterTypes ::= LPAREN [constantTypeSpecial (COMMA constantTypeSpecial)* [COMMA]] RPAREN
constantTypeFunction ::= FN [constantFunctionParameterTypes] R_ARROW constantTypeSpecial

constantTuple ::= HASH LPAREN [constantValue (COMMA constantValue)* [COMMA]] RPAREN
constantTypeTuple ::= HASH LPAREN [constantTypeSpecial (COMMA constantTypeSpecial)* [COMMA]] RPAREN

constantTypeArgument ::= constantTypeSpecial
constantTypeArguments ::= LPAREN [constantTypeArgument (COMMA constantTypeArgument)* [COMMA]] RPAREN

constantList ::= LBRACK [constantValue (COMMA constantValue)* [COMMA]] RBRACK

constantRecordArgument ::= [label COLON] constantValue
constantRecordArguments ::= LPAREN [constantRecordArgument (COMMA constantRecordArgument)* [COMMA]] RPAREN
constantRecord ::= (constructorIdentifier | remoteConstructorIdentifier) [constantRecordArguments]


bitArrayOptionName ::= IDENTIFIER
bitArraySegmentOption ::= bitArrayOptionName [LPAREN wholeNumber RPAREN] | wholeNumber
bitArraySegmentOptions ::= bitArraySegmentOption (MINUS bitArraySegmentOption)*

constantBitArraySegment ::= constantValue [COLON bitArraySegmentOptions]
constantBitArray ::= LT_LT [constantBitArraySegment (COMMA constantBitArraySegment)* [COMMA]] GT_GT

constantType ::= (typeIdentifier | remoteTypeIdentifier) [constantTypeArguments]
constantTypeSpecial ::= typeIdentifier
                      | constantTypeTuple
                      | constantTypeFunction
                      | constantType
constantTypeAnnotation ::= COLON constantType
constantFieldAccess ::= IDENTIFIER DOT label
constantValue ::= constantTuple
                | constantList
                | constantBitArray
                | constantRecord
                | IDENTIFIER
                | constantFieldAccess
                | literalExpr
constant ::= [visibilityModifier] CONST IDENTIFIER [constantTypeAnnotation] EQUAL constantValue

typeParameters ::= LPAREN [typeParameter (COMMA typeParameter)* [COMMA]] RPAREN
typeName ::= (typeIdentifier | remoteTypeIdentifier) [typeParameters]

functionParameterTypes ::= LPAREN [typeBase (COMMA typeBase)* [COMMA]] RPAREN
tupleType ::= HASH LPAREN [typeBase (COMMA typeBase)* [COMMA]] RPAREN
functionType ::= FN [functionParameterTypes] R_ARROW typeBase

genericIdentifier ::= IDENTIFIER
typeBase ::= typeReference | tupleType | functionType | genericIdentifier
typeAnnotation ::= COLON typeBase
typeArgument ::= typeBase
typeArguments ::= LPAREN [typeArgument (COMMA typeArgument)* [COMMA]] RPAREN
typeReference ::= (typeIdentifier | remoteTypeIdentifier) [typeArguments]

functionParameterArgs ::= labeledDiscardParam | discardParam | labeledNameParam | nameParam
functionParameter ::= functionParameterArgs [typeAnnotation]
functionParameters ::= LPAREN [functionParameter (COMMA functionParameter)* [COMMA]] RPAREN
functionBody ::= LBRACE [expressionSeq] RBRACE
functionDeclaration ::= (decorator)* [visibilityModifier] FN functionNameDefinition functionParameters [R_ARROW typeBase] functionBody
functionNameDefinition::= IDENTIFIER

listPatternTail ::= DOT_DOT [IDENTIFIER | discard]
listPattern ::= LBRACK [pattern (COMMA pattern)* [COMMA]] [listPatternTail] RBRACK

patternBitArraySegment ::= pattern [COLON bitArraySegmentOptions]
patternBitArray ::= LT_LT [patternBitArraySegment (COMMA patternBitArraySegment)* [COMMA]] GT_GT
stringPattern ::= stringLiteral LT_GT [IDENTIFIER | discard]

tuplePattern ::= HASH LPAREN [pattern (COMMA pattern)* [COMMA]] RPAREN
patternSpread ::= DOT_DOT [COMMA]
recordPatternArgument ::= [label COLON] pattern
recordPatternArguments ::= LPAREN [recordPatternArgument (COMMA recordPatternArgument)* [COMMA]] [patternSpread] RPAREN
recordPattern ::= (constructorIdentifier | remoteConstructorIdentifier) [recordPatternArguments]
pattern ::= (IDENTIFIER | discard | stringPattern | recordPattern | literalExpr | tuplePattern | patternBitArray | listPattern ) [AS IDENTIFIER]


expressionSeq ::= (expression)+

recordArgument ::= [label COLON] (expression)
private recordArgumentList ::= [recordArgument (COMMA recordArgument)* [COMMA]]
recordUpdate ::= DOT_DOT variableReference {pin=1}
// Record update can only be at the start of record arguments
recordArguments ::=  LPAREN (recordUpdate COMMA recordArgumentList | recordUpdate | recordArgumentList) RPAREN
recordExpr ::= (constructorIdentifier | remoteConstructorIdentifier) [recordArguments]

bitArraySegment ::= expression [COLON bitArraySegmentOptions]
bitArrayExpr ::= LT_LT [bitArraySegment (COMMA bitArraySegment)* [COMMA]] GT_GT {pin=1}
//private bitArrayRecover ::= !(GT_GT | LT_LT)

tupleExpr ::= HASH LPAREN [expression (COMMA expression)* [COMMA]] RPAREN {pin=2}
listExpr ::= LBRACK [expression ((COMMA expression)*)? [COMMA] [DOT_DOT expression]] RBRACK

anonymousFunctionParameterArgs ::= discardParam | nameParam
anonymousFunctionParameter ::= anonymousFunctionParameterArgs [typeAnnotation]
anonymousFunctionParameters ::= LPAREN [anonymousFunctionParameter (COMMA anonymousFunctionParameter)* [COMMA]] RPAREN
anonymousFunctionExpr ::= FN anonymousFunctionParameters [R_ARROW typeReference] functionBody

blockExpr ::= LBRACE expressionSeq RBRACE

caseClauseTupleAccess ::= IDENTIFIER DOT wholeNumber
caseClauseGuardUnit ::= IDENTIFIER | caseClauseTupleAccess | LBRACE caseClauseGuardExpression RBRACE | constantValue
caseClauseGuardBinaryOperator ::= VBAR_VBAR | AMPER_AMPER | EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
                                | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT | GREATER_EQUAL_DOT
caseClauseGuardExpression ::= caseClauseGuardUnit caseClauseGuardTail*
caseClauseGuardTail ::= caseClauseGuardBinaryOperator caseClauseGuardUnit

caseClauseGuard ::= IF caseClauseGuardExpression
caseClausePattern ::= pattern (COMMA pattern)* [COMMA]
caseClausePatterns ::= caseClausePattern (VBAR caseClausePattern)* [VBAR]
caseClause ::= caseClausePatterns [caseClauseGuard] R_ARROW expression
caseClauses ::= caseClause+
caseSubjects ::= expression (COMMA expression)*
caseExpr ::= CASE caseSubjects LBRACE caseClauses RBRACE

useArgs ::= IDENTIFIER | IDENTIFIER COMMA useArgs
useExpr ::= USE [useArgs] L_ARROW expression

assignment ::= pattern [typeAnnotation] EQUAL expression
simpleLetExpr ::= LET assignment {pin=1}
assertLetExpr ::= LET ASSERT assignment {pin=2}
letExpr ::= assertLetExpr | simpleLetExpr

panicExpr ::= PANIC (AS stringLiteral)?
todoExpr ::= TODO (AS stringLiteral)?

recordUpdateArgument ::= label COLON expression
recordUpdateArguments ::= recordUpdateArgument (COMMA recordUpdateArgument)* [COMMA]
recordUpdateExpr ::= (constructorIdentifier | remoteConstructorIdentifier) LPAREN DOT_DOT expression COMMA recordUpdateArguments RPAREN



callExpr ::= expression recordArguments

accessExpr ::= expression DOT (label | wholeNumber)

referenceExpr ::= IDENTIFIER

literalExpr ::= floatLiteral
              | stringLiteral
              | integerLiteral
              | BOOLEAN_LITERAL

private simpleKeywordExpr ::= letExpr | panicExpr | todoExpr
expression ::= simpleKeywordExpr
             | useExpr
             | caseExpr
             | tupleExpr
             | literalExpr
             | bitArrayExpr
             | callExpr
             | accessExpr
             | recordExpr
             | anonymousFunctionExpr
             | listExpr
             | blockExpr
             | recordUpdateExpr
             | referenceExpr
             | binaryExpr
             | unaryExpr

//private expressionRecoverWhile ::= !expressionRecoverUntil
//private expressionRecoverUntil ::= RBRACE | RPAREN | RBRACK | EOL


binaryExpr ::= expression binaryOperator expression
binaryOperator ::= EQUAL_EQUAL | NOT_EQUAL | LESS | LESS_EQUAL | LESS_DOT
                 | LESS_EQUAL_DOT | GREATER | GREATER_EQUAL | GREATER_DOT
                 | GREATER_EQUAL_DOT | LT_GT | PIPE | PLUS | PLUS_DOT
                 | MINUS | MINUS_DOT | STAR | STAR_DOT | SLASH | SLASH_DOT
                 | PERCENT | AMPER_AMPER | VBAR_VBAR

unaryExpr ::= unaryOperator expression
unaryOperator ::= BANG | MINUS

//// Types
dataConstructorArgument ::= [label COLON] typeBase
dataConstructorArguments ::= LPAREN [dataConstructorArgument (COMMA dataConstructorArgument)* [COMMA]] RPAREN
dataConstructor ::= constructorIdentifier [dataConstructorArguments]
dataConstructors ::= dataConstructor+


referenceTypeValue ::= EQUAL typeReference
customTypeValue ::= LBRACE dataConstructors RBRACE
omittedTypeValue ::=
typeValue ::= referenceTypeValue | customTypeValue | omittedTypeValue
typeDeclaration ::= [visibilityModifier] [opacityModifier] TYPE typeName typeValue {pin=3}

//// Numbers
binaryIntegerLiteral ::= BASE_NUMBER_PREFIX BINARY_NUMBER_BASE VALID_BINARY_DIGIT (NUMBER_SEPARATOR VALID_BINARY_DIGIT)*
octalIntegerLiteral ::= BASE_NUMBER_PREFIX OCTAL_NUMBER_BASE VALID_OCTAL_DIGIT (NUMBER_SEPARATOR VALID_OCTAL_DIGIT)*
hexIntegerLiteral ::= BASE_NUMBER_PREFIX HEX_NUMBER_BASE VALID_HEX_DIGIT (NUMBER_SEPARATOR VALID_HEX_DIGIT)*

wholeNumber ::= VALID_DECIMAL_DIGIT (NUMBER_SEPARATOR VALID_DECIMAL_DIGIT)*
decimalIntegerLiteral ::= wholeNumber

floatLiteral ::= wholeNumber DECIMAL_MARK wholeNumber? (EXPONENT_MARK EXPONENT_SIGN? wholeNumber)?
integerLiteral ::= binaryIntegerLiteral | octalIntegerLiteral | hexIntegerLiteral | decimalIntegerLiteral


//// Strings
stringEscapeSegment ::= (ESCAPE ESCAPE_CHAR) | (ESCAPE UNICODE_ESCAPE_CHAR LBRACE UNICODE_CODEPOINT RBRACE)
stringLiteral ::= OPEN_QUOTE (REGULAR_STRING_PART | stringEscapeSegment)* CLOSE_QUOTE


// Aliases
variableReference ::= IDENTIFIER
constructorIdentifier ::= UP_IDENTIFIER
typeIdentifier ::= UP_IDENTIFIER
discard ::= DISCARD_NAME
label ::= IDENTIFIER
typeParameter ::= IDENTIFIER
discardParam ::= discard
nameParam ::= IDENTIFIER
labeledNameParam ::= label IDENTIFIER
labeledDiscardParam ::= label discard
remoteConstructorIdentifier ::= IDENTIFIER DOT constructorIdentifier
remoteTypeIdentifier ::= IDENTIFIER DOT typeIdentifier
visibilityModifier ::= PUB
opacityModifier ::= OPAQUE
